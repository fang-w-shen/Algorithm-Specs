// write in a function thats a X by X array of arrays of numbers
// as well two x/y combinations and have it return the shortest
// length (you don't need to track the actual path) from point A
// to point B.
//
// the numbers in the maze array represent as follows:
// 0 – open space
// 1 - closed space, cannot pass through. a wall
// 2 - one of the two origination points
//
// you will almost certainly need to transform the maze into your own
// data structure to keep track of all the meta data

// this is a little tool I wrote to log out the maze to the console.
// it is opinionated of how to do that and you do not have to do it
// the way I did. however feel free to use it if you'd like
const logMaze = require("./logger");

function findShortestPathLength(maze, [xA, yA], [xB, yB]) {
  // code goes here
  const visited = maze.map((row, y) =>
    row.map((origin, x) => ({
      closed: origin === 1,
      iteration: 0,
      openedBy: 0,
      x,
      y
    }))
  )
  visited[yA][xA].openedBy = "A"
  visited[yB][xB].openedBy = "B";
  let aq = [visited[yA][xA]]
  let bq = [visited[yB][xB]]
  let found = false
  let steps = 0
  while (aq.length && bq.length) {
    steps++
    let aNeighbors = []
    let bNeighbors = []
    // USE AQUEUE TO GET ANEIGHBORS

    while (aq.length) {
      const coord = aq.shift()
      aNeighbors.push(...getNeighbors(visited, coord.x, coord.y))
    }
    // USE NEW ANEIGHBORS TO REFILL AQUEUE

    while (!found && aNeighbors.length) {
      let neighbor = aNeighbors.shift()
      if (neighbor && neighbor.openedBy == "B") {
        return neighbor.iteration + steps

      }
      else if (neighbor && neighbor.openedBy == 0) {
        neighbor.openedBy = "A"
        neighbor.iteration = steps
        aq.push(neighbor)
      }

    }
    // USE BQUEUE TO GET BNEIGHBORS
    while (bq.length) {
      const coord = bq.shift()
      bNeighbors.push(...getNeighbors(visited, coord.x, coord.y))
      // console.log(aNeighbors)
    }
    // USE NEW BNEIGHBORS TO REFILL BQUEUE
    while (!found && bNeighbors.length) {
      let neighbor = bNeighbors.shift()
      if (neighbor && neighbor.openedBy == "A") {
        return neighbor.iteration + steps
      }
      else if (neighbor && neighbor.openedBy == 0) {
        neighbor.openedBy = "B"
        neighbor.iteration = steps
        bq.push(neighbor)
      }

    }
  }
  return -1
}

function getNeighbors(node, x, y) {
  let left = right = down = up = null
  if (x - 1 >= 0 && !node[y][x - 1].closed)
    left = node[y][x - 1]
  if (y - 1 >= 0 && !node[y - 1][x].closed)
    up = node[y - 1][x]
  if (x + 1 <= node[0].length - 1 && !node[y][x + 1].closed)
    right = node[y][x + 1]
  if (y + 1 <= node.length - 1 && !node[y + 1][x].closed)
    down = node[y + 1][x]
  return [left, right, up, down]
}
// there is a visualization tool in the completed exercise
// it requires you to shape your objects like I did
// see the notes there if you want to use it

// unit tests
// do not modify the below code
describe("pathfinding – happy path", function () {
  const fourByFour = [
    [2, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 2]
  ];
  it("should solve a 4x4 maze", () => {
    expect(findShortestPathLength(fourByFour, [0, 0], [3, 3])).toEqual(6);
  });

  const sixBySix = [
    [0, 0, 0, 0, 0, 0],
    [0, 2, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 2, 0, 0, 0]
  ];
  it("should solve a 6x6 maze", () => {
    expect(findShortestPathLength(sixBySix, [1, 1], [2, 5])).toEqual(7);
  });

  const eightByEight = [
    [0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 0, 0, 1],
    [0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 1, 0, 1, 1, 0],
    [0, 0, 0, 0, 0, 0, 1, 0],
    [0, 2, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 1, 2]
  ];
  it("should solve a 8x8 maze", () => {
    expect(findShortestPathLength(eightByEight, [1, 7], [7, 7])).toEqual(16);
  });

  const fifteenByFifteen = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],
    [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0],
    [0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0],
    [0, 0, 1, 0, 1, 0, 1, 1, 2, 1, 0, 1, 0, 1, 0],
    [0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  ];
  it("should solve a 15x15 maze", () => {
    expect(findShortestPathLength(fifteenByFifteen, [1, 1], [8, 8])).toEqual(
      78
    );
  });
});

// I care far less if you solve these
// nonetheless, if you're having fun, solve some of the edge cases too!
// just remove the .skip from describe.skip
describe("pathfinding – edge cases", function () {
  const byEachOther = [
    [0, 0, 0, 0, 0],
    [0, 2, 2, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 1, 1, 1, 1],
    [0, 0, 0, 0, 0]
  ];
  it("should solve the maze if they're next to each other", () => {
    expect(findShortestPathLength(byEachOther, [1, 1], [2, 1])).toEqual(1);
  });

  const impossible = [
    [0, 0, 0, 0, 0],
    [0, 2, 0, 0, 0],
    [0, 0, 1, 1, 1],
    [1, 1, 1, 0, 0],
    [0, 0, 0, 0, 2]
  ];
  it("should return -1 when there's no possible path", () => {
    expect(findShortestPathLength(impossible, [1, 1], [4, 4])).toEqual(-1);
  });
});
